<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Szachownica: ChessGame Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="projectlogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Szachownica<span id="projectnumber">&#160;finish stage</span>
   </div>
   <div id="projectbrief">Projekt na zaliczenie przedmiotu Zaawansowane C++</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_chess_game.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_chess_game-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ChessGame Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="chessgame_8h_source.html">chessgame.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac33456bee1050132e25817da287cbed4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac33456bee1050132e25817da287cbed4"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_chess_game.html#ac33456bee1050132e25817da287cbed4">getPieceColor</a> (T x, T y=0)</td></tr>
<tr class="memdesc:ac33456bee1050132e25817da287cbed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">template ustalający kolor pionka na planszy na podstawie albo współrzędnych tablicy: rzędu i kolumny zdefiniowanych jako int od 0 do 7 albo pionka: char wilkiej lub małej litery  <a href="class_chess_game.html#ac33456bee1050132e25817da287cbed4">More...</a><br /></td></tr>
<tr class="separator:ac33456bee1050132e25817da287cbed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9d1caa97c7ca5737f187a6066662b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a7c9d1caa97c7ca5737f187a6066662b2">ChessGame</a> ()</td></tr>
<tr class="memdesc:a7c9d1caa97c7ca5737f187a6066662b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Konstruktor.  <a href="class_chess_game.html#a7c9d1caa97c7ca5737f187a6066662b2">More...</a><br /></td></tr>
<tr class="separator:a7c9d1caa97c7ca5737f187a6066662b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20298d8900be674dd560732f7d27e641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a20298d8900be674dd560732f7d27e641">initializeBoard</a> ()</td></tr>
<tr class="memdesc:a20298d8900be674dd560732f7d27e641"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja tworząca początkowe ustawienie pionków na planszy  <a href="class_chess_game.html#a20298d8900be674dd560732f7d27e641">More...</a><br /></td></tr>
<tr class="separator:a20298d8900be674dd560732f7d27e641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262ec5b9db57f8d89a1d706d75352155"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a262ec5b9db57f8d89a1d706d75352155">getWhosTurn</a> ()</td></tr>
<tr class="memdesc:a262ec5b9db57f8d89a1d706d75352155"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter pola whosTurn  <a href="class_chess_game.html#a262ec5b9db57f8d89a1d706d75352155">More...</a><br /></td></tr>
<tr class="separator:a262ec5b9db57f8d89a1d706d75352155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f2e5c3f05782d786b473c29000c3a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a58f2e5c3f05782d786b473c29000c3a5">changeTurn</a> ()</td></tr>
<tr class="memdesc:a58f2e5c3f05782d786b473c29000c3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter pola whosTurn ustawia pole na przeciwne do teraźniejszego, jeżeli kolej była białego gracza to teraz będzie czarnego  <a href="class_chess_game.html#a58f2e5c3f05782d786b473c29000c3a5">More...</a><br /></td></tr>
<tr class="separator:a58f2e5c3f05782d786b473c29000c3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c79d5b20d610a97ae95cdea682b2223"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a8c79d5b20d610a97ae95cdea682b2223">checkPieceAtPosition</a> (int row, int column)</td></tr>
<tr class="memdesc:a8c79d5b20d610a97ae95cdea682b2223"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja sprawdzająca tablicę board[8][8] jaki pionek znajduje sie na danej pozycji  <a href="class_chess_game.html#a8c79d5b20d610a97ae95cdea682b2223">More...</a><br /></td></tr>
<tr class="separator:a8c79d5b20d610a97ae95cdea682b2223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6234d5c417f5deea1e368abba8932b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a8d6234d5c417f5deea1e368abba8932b">isMoveValid</a> (Move move)</td></tr>
<tr class="memdesc:a8d6234d5c417f5deea1e368abba8932b"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja isMoveValid po podaniu struktury move sprawdza czy ruch jest możliwy dla danego pionka (w zależności od figury) na dane pole sprawdza również czy na docelowym polu nie ma pionka w tym samym kolorze funkcja ta wykorzystywana jest przy podświetlaniu pól aktywnych na planszy jak i pprzy sprawdzeniu szacha i szach mat  <a href="class_chess_game.html#a8d6234d5c417f5deea1e368abba8932b">More...</a><br /></td></tr>
<tr class="separator:a8d6234d5c417f5deea1e368abba8932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d533965bbf8c2bd3ed52177217cd939"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a7d533965bbf8c2bd3ed52177217cd939">checkDiagonalMove</a> (Move move)</td></tr>
<tr class="memdesc:a7d533965bbf8c2bd3ed52177217cd939"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja pomocnicza przy ustalaniu czy ruch po skosie jest możliwy wywoływana w isMoveValid dla królowej i gońca  <a href="class_chess_game.html#a7d533965bbf8c2bd3ed52177217cd939">More...</a><br /></td></tr>
<tr class="separator:a7d533965bbf8c2bd3ed52177217cd939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb28166d01976848b4737037b41744c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#abb28166d01976848b4737037b41744c1">movePiece</a> ()</td></tr>
<tr class="memdesc:abb28166d01976848b4737037b41744c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja movePiece wykonująca ruch na tablicy board na podstawie informacji o ruchu ThisMove usuwa pionek i stawia go w nowy miejscu wywołuje funkcje aktualizujące parametry gry  <a href="class_chess_game.html#abb28166d01976848b4737037b41744c1">More...</a><br /></td></tr>
<tr class="separator:abb28166d01976848b4737037b41744c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e431f86de755e6caddebc25db7298f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#ad1e431f86de755e6caddebc25db7298f">doCastleMove</a> ()</td></tr>
<tr class="memdesc:ad1e431f86de755e6caddebc25db7298f"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja pomocnicza wykonująca ruch roszadowy dla ThisMove  <a href="class_chess_game.html#ad1e431f86de755e6caddebc25db7298f">More...</a><br /></td></tr>
<tr class="separator:ad1e431f86de755e6caddebc25db7298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77814bbcb54f169c079a68cb24d82134"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a77814bbcb54f169c079a68cb24d82134">checkCheck</a> ()</td></tr>
<tr class="memdesc:a77814bbcb54f169c079a68cb24d82134"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja sprawdzająca czy w obecnym ustawieniu pionków na tablicy board jest możliwość zbicia króla jakiegokolwiek koloru czyli czy jest szach  <a href="class_chess_game.html#a77814bbcb54f169c079a68cb24d82134">More...</a><br /></td></tr>
<tr class="separator:a77814bbcb54f169c079a68cb24d82134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6384535c736f207d8b01a0cad0bce0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#aeb6384535c736f207d8b01a0cad0bce0">checkCheck</a> (char color, int whatPiece_row, int whatPiece_column)</td></tr>
<tr class="memdesc:aeb6384535c736f207d8b01a0cad0bce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">nadpisanie metody checkCheck: funkcja sprawdzająca czy w nowym potencjalnym ustawieniu króla będzie szach wywoływana przy sprawdzaniu szach mat  <a href="class_chess_game.html#aeb6384535c736f207d8b01a0cad0bce0">More...</a><br /></td></tr>
<tr class="separator:aeb6384535c736f207d8b01a0cad0bce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8334c75e5ccb6115d42bbe913a902ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a8334c75e5ccb6115d42bbe913a902ed2">setChecktoFalse</a> ()</td></tr>
<tr class="memdesc:a8334c75e5ccb6115d42bbe913a902ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter funkcja po sprawdzeniu czy jest szach na planszy ustawia hasCheck na false dla obu graczy  <a href="class_chess_game.html#a8334c75e5ccb6115d42bbe913a902ed2">More...</a><br /></td></tr>
<tr class="separator:a8334c75e5ccb6115d42bbe913a902ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0041a6e90e5c73986877a042193b02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a5c0041a6e90e5c73986877a042193b02">checkMate</a> (char piece)</td></tr>
<tr class="memdesc:a5c0041a6e90e5c73986877a042193b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja sprawdzająca czy dla obecnego ustawienia pionków jest szach mat  <a href="class_chess_game.html#a5c0041a6e90e5c73986877a042193b02">More...</a><br /></td></tr>
<tr class="separator:a5c0041a6e90e5c73986877a042193b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b5e3f219be81159db630c1b2a83ddc"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a53b5e3f219be81159db630c1b2a83ddc">returnAvailableFields</a> (int whatPiece_row, int whatPiece_column)</td></tr>
<tr class="memdesc:a53b5e3f219be81159db630c1b2a83ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja zwracająca dostępne pola do poruszenia w postaci wektora dla pionka położonego (whatPiece_row,whatPiece_column) wywoływana w kontrolerze  <a href="class_chess_game.html#a53b5e3f219be81159db630c1b2a83ddc">More...</a><br /></td></tr>
<tr class="separator:a53b5e3f219be81159db630c1b2a83ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cd11f1d7ef389743d859f2a0237ca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a45cd11f1d7ef389743d859f2a0237ca5">addToCaptured</a> (char piece)</td></tr>
<tr class="memdesc:a45cd11f1d7ef389743d859f2a0237ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja dodająca zbity pionek do wektora wzbitych pionków gracza  <a href="class_chess_game.html#a45cd11f1d7ef389743d859f2a0237ca5">More...</a><br /></td></tr>
<tr class="separator:a45cd11f1d7ef389743d859f2a0237ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd41c67e994941cf7fa90a778a11145d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#afd41c67e994941cf7fa90a778a11145d">saveThisMove</a> (char _figure, int _whatPiece_row, int _whatPiece_column, int _putWhere_row, int _putWhere_column)</td></tr>
<tr class="memdesc:afd41c67e994941cf7fa90a778a11145d"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter obiektu ThisMove ustawia obecny/potencjalny (jeszcze nie dokonany) ruch  <a href="class_chess_game.html#afd41c67e994941cf7fa90a778a11145d">More...</a><br /></td></tr>
<tr class="separator:afd41c67e994941cf7fa90a778a11145d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384a218c740127f0ff61429f6e34fdcc"><td class="memItemLeft" align="right" valign="top">Move&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a384a218c740127f0ff61429f6e34fdcc">getLastMove</a> ()</td></tr>
<tr class="memdesc:a384a218c740127f0ff61429f6e34fdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter obiektu LastMove zwraca ostatni ruch jaki był wykonany  <a href="class_chess_game.html#a384a218c740127f0ff61429f6e34fdcc">More...</a><br /></td></tr>
<tr class="separator:a384a218c740127f0ff61429f6e34fdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1834fc1be8509272f29bb72a5e50847e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a1834fc1be8509272f29bb72a5e50847e">saveLastMove</a> (char _figure, int _whatPiece_row, int _whatPiece_column, int _putWhere_row, int _putWhere_column)</td></tr>
<tr class="memdesc:a1834fc1be8509272f29bb72a5e50847e"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter obiektu LastMove ustawia ostatni ruch jaki był wykonany  <a href="class_chess_game.html#a1834fc1be8509272f29bb72a5e50847e">More...</a><br /></td></tr>
<tr class="separator:a1834fc1be8509272f29bb72a5e50847e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5619f0ea3cbc98f601376059d23ca3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#abe5619f0ea3cbc98f601376059d23ca3">doublePawnMove</a> (Move move)</td></tr>
<tr class="memdesc:abe5619f0ea3cbc98f601376059d23ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja pomocnicza przy ustalaniu czy ruch pionka o dwa pola do przodu jest możliwy wywoływana w isMoveValid  <a href="class_chess_game.html#abe5619f0ea3cbc98f601376059d23ca3">More...</a><br /></td></tr>
<tr class="separator:abe5619f0ea3cbc98f601376059d23ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd323d512455c8518bfd2bf26ec2e812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#abd323d512455c8518bfd2bf26ec2e812">saveNewKingsPosition</a> (char piece, int row, int column)</td></tr>
<tr class="memdesc:abd323d512455c8518bfd2bf26ec2e812"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja zapisująca nową pozycję króla wywoływana po wykonaniu ruchu w movePiece  <a href="class_chess_game.html#abd323d512455c8518bfd2bf26ec2e812">More...</a><br /></td></tr>
<tr class="separator:abd323d512455c8518bfd2bf26ec2e812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dadf58306caae13d3a784e4b5a085cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a2dadf58306caae13d3a784e4b5a085cd">isKingsMoveValid</a> (char color, int putWhere_row, int putWhere_column)</td></tr>
<tr class="memdesc:a2dadf58306caae13d3a784e4b5a085cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja spprawdzająca czy potencjalny ruch króla jest możliwy wywoływana przy sprawdzeniu czy ruch jest możliwy oraz przy sprawdzeniu szach mat  <a href="class_chess_game.html#a2dadf58306caae13d3a784e4b5a085cd">More...</a><br /></td></tr>
<tr class="separator:a2dadf58306caae13d3a784e4b5a085cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00a5900fa9d93d5d59e9892dd24edcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#ae00a5900fa9d93d5d59e9892dd24edcc">saveCastlePossib</a> (int whatPiece_row, int whatPiece_column)</td></tr>
<tr class="memdesc:ae00a5900fa9d93d5d59e9892dd24edcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja zapisująca ruch wiezy i ustawiająca możliwość orszady na false wywoływana po wykonaniu ruchu przez wieżę w movePiece  <a href="class_chess_game.html#ae00a5900fa9d93d5d59e9892dd24edcc">More...</a><br /></td></tr>
<tr class="separator:ae00a5900fa9d93d5d59e9892dd24edcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e0b4d1f80b352c34a3c3cb8af65fad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#ad8e0b4d1f80b352c34a3c3cb8af65fad">isCastleMove</a> (char pieceColor, int putWhere_row, int putWhere_column)</td></tr>
<tr class="memdesc:ad8e0b4d1f80b352c34a3c3cb8af65fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja sprawdzająca czy roszada na dane pole jest możliwa wywoływana w sprawdzeniu dostępności pól (dla króla) oraz przy wykonywaniu ruchu  <a href="class_chess_game.html#ad8e0b4d1f80b352c34a3c3cb8af65fad">More...</a><br /></td></tr>
<tr class="separator:ad8e0b4d1f80b352c34a3c3cb8af65fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd4dbef73e922581de01f2e50515581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a1cd4dbef73e922581de01f2e50515581">removePiece</a> (int row, int column)</td></tr>
<tr class="memdesc:a1cd4dbef73e922581de01f2e50515581"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja usuwająca pionek z tablicy board (zamieniająca wartość na EMPTY)  <a href="class_chess_game.html#a1cd4dbef73e922581de01f2e50515581">More...</a><br /></td></tr>
<tr class="separator:a1cd4dbef73e922581de01f2e50515581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cbf6f447ff24730904c3ee5bc582dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a88cbf6f447ff24730904c3ee5bc582dc">addPiece</a> (char piece, int row, int column)</td></tr>
<tr class="memdesc:a88cbf6f447ff24730904c3ee5bc582dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja dodająca pionek do tablicy board  <a href="class_chess_game.html#a88cbf6f447ff24730904c3ee5bc582dc">More...</a><br /></td></tr>
<tr class="separator:a88cbf6f447ff24730904c3ee5bc582dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bde32cb3107a39dad542e0cf88f593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a82bde32cb3107a39dad542e0cf88f593">resetMove</a> (Move move)</td></tr>
<tr class="memdesc:a82bde32cb3107a39dad542e0cf88f593"><td class="mdescLeft">&#160;</td><td class="mdescRight">funkcja resetująca wartości struktury Move - na początku każdej nowej gry  <a href="class_chess_game.html#a82bde32cb3107a39dad542e0cf88f593">More...</a><br /></td></tr>
<tr class="separator:a82bde32cb3107a39dad542e0cf88f593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff71707313a81dee8c38dedd0479ac3"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#afff71707313a81dee8c38dedd0479ac3">getWhosCheckMate</a> () const</td></tr>
<tr class="memdesc:afff71707313a81dee8c38dedd0479ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter i setter pola whosCheckMate  <a href="class_chess_game.html#afff71707313a81dee8c38dedd0479ac3">More...</a><br /></td></tr>
<tr class="separator:afff71707313a81dee8c38dedd0479ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6612cb088a3f05fd33589ebef1b46b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#aba6612cb088a3f05fd33589ebef1b46b">setWhosCheckMate</a> (char value)</td></tr>
<tr class="separator:aba6612cb088a3f05fd33589ebef1b46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d28d5fed95f54dce633c60f52a5d770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_player.html">Player</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a7d28d5fed95f54dce633c60f52a5d770">getWhite</a> () const</td></tr>
<tr class="memdesc:a7d28d5fed95f54dce633c60f52a5d770"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter i setter pola <a class="el" href="class_player.html" title="klasa Player Reprezentuje gracza w tym kolor jego pionków, ustawienie króla, zbite pionki przechowuje...">Player</a>  <a href="class_chess_game.html#a7d28d5fed95f54dce633c60f52a5d770">More...</a><br /></td></tr>
<tr class="separator:a7d28d5fed95f54dce633c60f52a5d770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8822b7af2d5c4a58223588fd85eccded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_player.html">Player</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a8822b7af2d5c4a58223588fd85eccded">getBlack</a> () const</td></tr>
<tr class="separator:a8822b7af2d5c4a58223588fd85eccded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4df4b316ebb80a930040019095e0a640"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a4df4b316ebb80a930040019095e0a640">WHITE_COLOR</a> = '<a class="el" href="controller_8cpp.html#a942d80abdc199f171e350d1e8fb8e676">w</a>'</td></tr>
<tr class="memdesc:a4df4b316ebb80a930040019095e0a640"><td class="mdescLeft">&#160;</td><td class="mdescRight">stała biały kolor  <a href="class_chess_game.html#a4df4b316ebb80a930040019095e0a640">More...</a><br /></td></tr>
<tr class="separator:a4df4b316ebb80a930040019095e0a640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693b82bd4438328aa003d12f47c947c5"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a693b82bd4438328aa003d12f47c947c5">BLACK_COLOR</a> = 'b'</td></tr>
<tr class="memdesc:a693b82bd4438328aa003d12f47c947c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">stała czarny kolor  <a href="class_chess_game.html#a693b82bd4438328aa003d12f47c947c5">More...</a><br /></td></tr>
<tr class="separator:a693b82bd4438328aa003d12f47c947c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb33157e08119a9cadda64751736fb2a"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#adb33157e08119a9cadda64751736fb2a">WHITE_KING</a> = 'K'</td></tr>
<tr class="memdesc:adb33157e08119a9cadda64751736fb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">stała pionek biały król  <a href="class_chess_game.html#adb33157e08119a9cadda64751736fb2a">More...</a><br /></td></tr>
<tr class="separator:adb33157e08119a9cadda64751736fb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4998b6bb96eab138dad56216491a74f"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#ad4998b6bb96eab138dad56216491a74f">BLACK_KING</a> = 'k'</td></tr>
<tr class="memdesc:ad4998b6bb96eab138dad56216491a74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">stała pionek czarny król  <a href="class_chess_game.html#ad4998b6bb96eab138dad56216491a74f">More...</a><br /></td></tr>
<tr class="separator:ad4998b6bb96eab138dad56216491a74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04335022c7e78e2b52a828734296fdca"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess_game.html#a04335022c7e78e2b52a828734296fdca">EMPTY</a> = 0x20</td></tr>
<tr class="memdesc:a04335022c7e78e2b52a828734296fdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">stała brak pionka na planszy  <a href="class_chess_game.html#a04335022c7e78e2b52a828734296fdca">More...</a><br /></td></tr>
<tr class="separator:a04335022c7e78e2b52a828734296fdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7c9d1caa97c7ca5737f187a6066662b2" name="a7c9d1caa97c7ca5737f187a6066662b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9d1caa97c7ca5737f187a6066662b2">&#9670;&nbsp;</a></span>ChessGame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChessGame::ChessGame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Konstruktor. </p>
<p >Tworzy instancję <a class="el" href="class_chess_game.html">ChessGame</a>, dwóch graczy <a class="el" href="class_player.html" title="klasa Player Reprezentuje gracza w tym kolor jego pionków, ustawienie króla, zbite pionki przechowuje...">Player</a>, ustawia kolej gracza białego, czyści informację o ruchach i szach mat ustawia początkowe pozycje króli wywoływany jest w kontrolerze </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88cbf6f447ff24730904c3ee5bc582dc" name="a88cbf6f447ff24730904c3ee5bc582dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cbf6f447ff24730904c3ee5bc582dc">&#9670;&nbsp;</a></span>addPiece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::addPiece </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>piece</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja dodająca pionek do tablicy board </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pionek,wiersz,kolumna</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45cd11f1d7ef389743d859f2a0237ca5" name="a45cd11f1d7ef389743d859f2a0237ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cd11f1d7ef389743d859f2a0237ca5">&#9670;&nbsp;</a></span>addToCaptured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::addToCaptured </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>piece</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja dodająca zbity pionek do wektora wzbitych pionków gracza </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbity</td><td>pionek (char) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58f2e5c3f05782d786b473c29000c3a5" name="a58f2e5c3f05782d786b473c29000c3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f2e5c3f05782d786b473c29000c3a5">&#9670;&nbsp;</a></span>changeTurn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::changeTurn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setter pola whosTurn ustawia pole na przeciwne do teraźniejszego, jeżeli kolej była białego gracza to teraz będzie czarnego </p>

</div>
</div>
<a id="a77814bbcb54f169c079a68cb24d82134" name="a77814bbcb54f169c079a68cb24d82134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77814bbcb54f169c079a68cb24d82134">&#9670;&nbsp;</a></span>checkCheck() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ChessGame::checkCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja sprawdzająca czy w obecnym ustawieniu pionków na tablicy board jest możliwość zbicia króla jakiegokolwiek koloru czyli czy jest szach </p>
<dl class="section return"><dt>Returns</dt><dd>kolor gracza dla którego jest szach, gdy nie ma szacha funkcja zwraca EMPTY </dd></dl>

</div>
</div>
<a id="aeb6384535c736f207d8b01a0cad0bce0" name="aeb6384535c736f207d8b01a0cad0bce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6384535c736f207d8b01a0cad0bce0">&#9670;&nbsp;</a></span>checkCheck() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChessGame::checkCheck </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whatPiece_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whatPiece_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>nadpisanie metody checkCheck: funkcja sprawdzająca czy w nowym potencjalnym ustawieniu króla będzie szach wywoływana przy sprawdzaniu szach mat </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">czy</td><td>jest szach dla króla w ustawieniu o kolorze color ustawionego na polu o współrzędnych whatPiece_row, whatPiece_column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fałsz gdy nie ma szacha </dd></dl>

</div>
</div>
<a id="a7d533965bbf8c2bd3ed52177217cd939" name="a7d533965bbf8c2bd3ed52177217cd939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d533965bbf8c2bd3ed52177217cd939">&#9670;&nbsp;</a></span>checkDiagonalMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChessGame::checkDiagonalMove </td>
          <td>(</td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja pomocnicza przy ustalaniu czy ruch po skosie jest możliwy wywoływana w isMoveValid dla królowej i gońca </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obiekt</td><td>Move: pionek, wiersz, kolumna, wiersz docelowy, kolumna docelowa </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>czy ruch jest możliwy dla danego ruchu move </dd></dl>

</div>
</div>
<a id="a5c0041a6e90e5c73986877a042193b02" name="a5c0041a6e90e5c73986877a042193b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0041a6e90e5c73986877a042193b02">&#9670;&nbsp;</a></span>checkMate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChessGame::checkMate </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>piece</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja sprawdzająca czy dla obecnego ustawienia pionków jest szach mat </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pionek</td><td>króla który jest szachowany </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true gdy jest szach mat </dd></dl>

</div>
</div>
<a id="a8c79d5b20d610a97ae95cdea682b2223" name="a8c79d5b20d610a97ae95cdea682b2223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c79d5b20d610a97ae95cdea682b2223">&#9670;&nbsp;</a></span>checkPieceAtPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ChessGame::checkPieceAtPosition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja sprawdzająca tablicę board[8][8] jaki pionek znajduje sie na danej pozycji </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wiersz,kolumna</td><td>od 0 do 8 (indexowanie od lewej do prawej od góry do dołu) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pionek znajdujący się na tym polu (char) </dd></dl>

</div>
</div>
<a id="ad1e431f86de755e6caddebc25db7298f" name="ad1e431f86de755e6caddebc25db7298f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e431f86de755e6caddebc25db7298f">&#9670;&nbsp;</a></span>doCastleMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::doCastleMove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja pomocnicza wykonująca ruch roszadowy dla ThisMove </p>

</div>
</div>
<a id="abe5619f0ea3cbc98f601376059d23ca3" name="abe5619f0ea3cbc98f601376059d23ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5619f0ea3cbc98f601376059d23ca3">&#9670;&nbsp;</a></span>doublePawnMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChessGame::doublePawnMove </td>
          <td>(</td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja pomocnicza przy ustalaniu czy ruch pionka o dwa pola do przodu jest możliwy wywoływana w isMoveValid </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obiekt</td><td>Move: pionek, wiersz, kolumna, wiersz docelowy, kolumna docelowa </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>czy ruch jest możliwy dla danego ruchu move </dd></dl>

</div>
</div>
<a id="a8822b7af2d5c4a58223588fd85eccded" name="a8822b7af2d5c4a58223588fd85eccded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8822b7af2d5c4a58223588fd85eccded">&#9670;&nbsp;</a></span>getBlack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_player.html">Player</a> * ChessGame::getBlack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a384a218c740127f0ff61429f6e34fdcc" name="a384a218c740127f0ff61429f6e34fdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384a218c740127f0ff61429f6e34fdcc">&#9670;&nbsp;</a></span>getLastMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChessGame::Move ChessGame::getLastMove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter obiektu LastMove zwraca ostatni ruch jaki był wykonany </p>
<dl class="section return"><dt>Returns</dt><dd>LastMove </dd></dl>

</div>
</div>
<a id="ac33456bee1050132e25817da287cbed4" name="ac33456bee1050132e25817da287cbed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33456bee1050132e25817da287cbed4">&#9670;&nbsp;</a></span>getPieceColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ChessGame::getPieceColor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>template ustalający kolor pionka na planszy na podstawie albo współrzędnych tablicy: rzędu i kolumny zdefiniowanych jako int od 0 do 7 albo pionka: char wilkiej lub małej litery </p>
<dl class="section return"><dt>Returns</dt><dd>kolor pionka na planszy (WHITE_COLOR,BLACK_COLOR) lub brak pionka (EMPTY) </dd></dl>

</div>
</div>
<a id="a7d28d5fed95f54dce633c60f52a5d770" name="a7d28d5fed95f54dce633c60f52a5d770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d28d5fed95f54dce633c60f52a5d770">&#9670;&nbsp;</a></span>getWhite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_player.html">Player</a> * ChessGame::getWhite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter i setter pola <a class="el" href="class_player.html" title="klasa Player Reprezentuje gracza w tym kolor jego pionków, ustawienie króla, zbite pionki przechowuje...">Player</a> </p>

</div>
</div>
<a id="afff71707313a81dee8c38dedd0479ac3" name="afff71707313a81dee8c38dedd0479ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff71707313a81dee8c38dedd0479ac3">&#9670;&nbsp;</a></span>getWhosCheckMate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ChessGame::getWhosCheckMate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter i setter pola whosCheckMate </p>

</div>
</div>
<a id="a262ec5b9db57f8d89a1d706d75352155" name="a262ec5b9db57f8d89a1d706d75352155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262ec5b9db57f8d89a1d706d75352155">&#9670;&nbsp;</a></span>getWhosTurn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ChessGame::getWhosTurn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter pola whosTurn </p>
<dl class="section return"><dt>Returns</dt><dd>kolor gracza którego jest teraz kolej </dd></dl>

</div>
</div>
<a id="a20298d8900be674dd560732f7d27e641" name="a20298d8900be674dd560732f7d27e641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20298d8900be674dd560732f7d27e641">&#9670;&nbsp;</a></span>initializeBoard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::initializeBoard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja tworząca początkowe ustawienie pionków na planszy </p>

</div>
</div>
<a id="ad8e0b4d1f80b352c34a3c3cb8af65fad" name="ad8e0b4d1f80b352c34a3c3cb8af65fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e0b4d1f80b352c34a3c3cb8af65fad">&#9670;&nbsp;</a></span>isCastleMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChessGame::isCastleMove </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pieceColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>putWhere_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>putWhere_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja sprawdzająca czy roszada na dane pole jest możliwa wywoływana w sprawdzeniu dostępności pól (dla króla) oraz przy wykonywaniu ruchu </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kolor</td><td>króla, parametry poruszonejgo króla docelowy wiersz i docelowa kolumna </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dadf58306caae13d3a784e4b5a085cd" name="a2dadf58306caae13d3a784e4b5a085cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dadf58306caae13d3a784e4b5a085cd">&#9670;&nbsp;</a></span>isKingsMoveValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChessGame::isKingsMoveValid </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>putWhere_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>putWhere_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja spprawdzająca czy potencjalny ruch króla jest możliwy wywoływana przy sprawdzeniu czy ruch jest możliwy oraz przy sprawdzeniu szach mat </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kolor</td><td>króla, wiersz docelowy, kolumna docelowa króla </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zwraca true gdy ruch króla jest możliwy </dd></dl>

</div>
</div>
<a id="a8d6234d5c417f5deea1e368abba8932b" name="a8d6234d5c417f5deea1e368abba8932b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6234d5c417f5deea1e368abba8932b">&#9670;&nbsp;</a></span>isMoveValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChessGame::isMoveValid </td>
          <td>(</td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja isMoveValid po podaniu struktury move sprawdza czy ruch jest możliwy dla danego pionka (w zależności od figury) na dane pole sprawdza również czy na docelowym polu nie ma pionka w tym samym kolorze funkcja ta wykorzystywana jest przy podświetlaniu pól aktywnych na planszy jak i pprzy sprawdzeniu szacha i szach mat </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">move</td><td>zawiera informację o pionku i o potencjalnym ruchu z jakiego miajsca na jakie (rząd, kolumna) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zwraca fałsz gdy ruch nie jest możliwy, true gdy jest możliwy (nie narusza zasad gry w sachy) </dd></dl>

</div>
</div>
<a id="abb28166d01976848b4737037b41744c1" name="abb28166d01976848b4737037b41744c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb28166d01976848b4737037b41744c1">&#9670;&nbsp;</a></span>movePiece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::movePiece </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja movePiece wykonująca ruch na tablicy board na podstawie informacji o ruchu ThisMove usuwa pionek i stawia go w nowy miejscu wywołuje funkcje aktualizujące parametry gry </p>

</div>
</div>
<a id="a1cd4dbef73e922581de01f2e50515581" name="a1cd4dbef73e922581de01f2e50515581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd4dbef73e922581de01f2e50515581">&#9670;&nbsp;</a></span>removePiece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::removePiece </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja usuwająca pionek z tablicy board (zamieniająca wartość na EMPTY) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wiersz</td><td>kolumna </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82bde32cb3107a39dad542e0cf88f593" name="a82bde32cb3107a39dad542e0cf88f593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bde32cb3107a39dad542e0cf88f593">&#9670;&nbsp;</a></span>resetMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::resetMove </td>
          <td>(</td>
          <td class="paramtype">Move&#160;</td>
          <td class="paramname"><em>move</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja resetująca wartości struktury Move - na początku każdej nowej gry </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">move</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53b5e3f219be81159db630c1b2a83ddc" name="a53b5e3f219be81159db630c1b2a83ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b5e3f219be81159db630c1b2a83ddc">&#9670;&nbsp;</a></span>returnAvailableFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; * ChessGame::returnAvailableFields </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whatPiece_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whatPiece_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja zwracająca dostępne pola do poruszenia w postaci wektora dla pionka położonego (whatPiece_row,whatPiece_column) wywoływana w kontrolerze </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wiersz,kolumna</td><td>pionka dla którego sprawdzane są możliwości ruchu </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>wskaźnik do wektora dostępnych pól &lt;int wiersz1, int kolumna1,int wiersz2, int kolumna2 &gt; </dd></dl>

</div>
</div>
<a id="ae00a5900fa9d93d5d59e9892dd24edcc" name="ae00a5900fa9d93d5d59e9892dd24edcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00a5900fa9d93d5d59e9892dd24edcc">&#9670;&nbsp;</a></span>saveCastlePossib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::saveCastlePossib </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whatPiece_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whatPiece_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja zapisująca ruch wiezy i ustawiająca możliwość orszady na false wywoływana po wykonaniu ruchu przez wieżę w movePiece </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parametry</td><td>poruszonej wieży wiersz i kolumna </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1834fc1be8509272f29bb72a5e50847e" name="a1834fc1be8509272f29bb72a5e50847e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1834fc1be8509272f29bb72a5e50847e">&#9670;&nbsp;</a></span>saveLastMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::saveLastMove </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>_figure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_whatPiece_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_whatPiece_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_putWhere_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_putWhere_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setter obiektu LastMove ustawia ostatni ruch jaki był wykonany </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parametry</td><td>Move: pionek, wiersz, kolumna, wiersz docelowy, kolumna docelowa </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd323d512455c8518bfd2bf26ec2e812" name="abd323d512455c8518bfd2bf26ec2e812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd323d512455c8518bfd2bf26ec2e812">&#9670;&nbsp;</a></span>saveNewKingsPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::saveNewKingsPosition </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>piece</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>funkcja zapisująca nową pozycję króla wywoływana po wykonaniu ruchu w movePiece </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wiersz</td><td>docelowy, kolumna docelowa króla </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd41c67e994941cf7fa90a778a11145d" name="afd41c67e994941cf7fa90a778a11145d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd41c67e994941cf7fa90a778a11145d">&#9670;&nbsp;</a></span>saveThisMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::saveThisMove </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>_figure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_whatPiece_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_whatPiece_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_putWhere_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_putWhere_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setter obiektu ThisMove ustawia obecny/potencjalny (jeszcze nie dokonany) ruch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parametry</td><td>Move: pionek, wiersz, kolumna, wiersz docelowy, kolumna docelowa </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8334c75e5ccb6115d42bbe913a902ed2" name="a8334c75e5ccb6115d42bbe913a902ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8334c75e5ccb6115d42bbe913a902ed2">&#9670;&nbsp;</a></span>setChecktoFalse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::setChecktoFalse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setter funkcja po sprawdzeniu czy jest szach na planszy ustawia hasCheck na false dla obu graczy </p>

</div>
</div>
<a id="aba6612cb088a3f05fd33589ebef1b46b" name="aba6612cb088a3f05fd33589ebef1b46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6612cb088a3f05fd33589ebef1b46b">&#9670;&nbsp;</a></span>setWhosCheckMate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChessGame::setWhosCheckMate </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a693b82bd4438328aa003d12f47c947c5" name="a693b82bd4438328aa003d12f47c947c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693b82bd4438328aa003d12f47c947c5">&#9670;&nbsp;</a></span>BLACK_COLOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char ChessGame::BLACK_COLOR = 'b'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stała czarny kolor </p>

</div>
</div>
<a id="ad4998b6bb96eab138dad56216491a74f" name="ad4998b6bb96eab138dad56216491a74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4998b6bb96eab138dad56216491a74f">&#9670;&nbsp;</a></span>BLACK_KING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char ChessGame::BLACK_KING = 'k'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stała pionek czarny król </p>

</div>
</div>
<a id="a04335022c7e78e2b52a828734296fdca" name="a04335022c7e78e2b52a828734296fdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04335022c7e78e2b52a828734296fdca">&#9670;&nbsp;</a></span>EMPTY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char ChessGame::EMPTY = 0x20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stała brak pionka na planszy </p>

</div>
</div>
<a id="a4df4b316ebb80a930040019095e0a640" name="a4df4b316ebb80a930040019095e0a640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df4b316ebb80a930040019095e0a640">&#9670;&nbsp;</a></span>WHITE_COLOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char ChessGame::WHITE_COLOR = '<a class="el" href="controller_8cpp.html#a942d80abdc199f171e350d1e8fb8e676">w</a>'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stała biały kolor </p>

</div>
</div>
<a id="adb33157e08119a9cadda64751736fb2a" name="adb33157e08119a9cadda64751736fb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb33157e08119a9cadda64751736fb2a">&#9670;&nbsp;</a></span>WHITE_KING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char ChessGame::WHITE_KING = 'K'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stała pionek biały król </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_chess_game.html">ChessGame</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
